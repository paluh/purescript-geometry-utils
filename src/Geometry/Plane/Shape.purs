module Geometry.Plane.Shape where

-- import Prelude
-- 
-- import Data.Argonaut (class DecodeJson, class EncodeJson)
-- import Data.Argonaut.Decode.Generic.Rep (genericDecodeJson)
-- import Data.Argonaut.Encode.Generic.Rep (genericEncodeJson)
-- import Data.Array.NonEmpty (NonEmptyArray)
-- import Data.Generic.Rep (class Generic)
-- import Geometry.Plane.BoundingBox (BoundingBox(..))
-- import Geometry.Plane.BoundingBox (intersection) as BoundingBox
-- import Geometry.Plane.Point (Point, distance)
-- import Geometry.Utils (maximum1, minimum1)
-- import Math (Radians, (%))
-- import Math (abs, pi, pow, sqrt, tan) as Math
-- import Unsafe.Coerce (unsafeCoerce)
-- 
-- -- | XXX: Probably we can drop `Circle` and use only `Ellipse`
-- data Shape u
--   = Circle { center ∷ Point u, radius ∷  Number }
--   | Ellipse { center ∷ Point u, rx ∷ Number , ry ∷ Number , rotation ∷ Radians }
--   | Quadrilateral { center ∷ Point u, p1 ∷ Point u, p2 ∷ Point u, p3 ∷ Point u, p4 ∷ Point u }
--   | Triangle { center ∷ Point u, p1 ∷ Point u, p2 ∷ Point u, p3 ∷ Point u }
-- derive instance eqShape ∷ Eq (Shape u)
-- derive instance genericShape ∷ Generic (Shape u) _
-- instance encodeShape ∷ EncodeJson (Shape u) where
--   encodeJson = genericEncodeJson
-- instance decodeDesign ∷ DecodeJson (Shape u) where
--   decodeJson = genericDecodeJson
-- 
-- -- intersection :: Shape -> Shape -> Boolean
-- -- intersection s1 s2 =
-- --   BoundingBox.intersection bb1 bb2
-- --   where
-- --     bb1 = boundingBox s1
-- --     bb2 = boundingBox s2
-- -- 
-- -- boundingBox ∷ Shape → BoundingBox
-- -- boundingBox = BoundingBox <<< case _ of
-- --   Circle { center, radius } →
-- --     { height: 2.0 * radius, width: 2.0 * radius, x: center.x - radius, y: center.y - radius }
-- -- 
-- --   Ellipse { center:c, rx, ry, rotation } →
-- --     -- tangent is zero
-- --     if rotation % Math.pi == 0.0
-- --     then {x: c.x - rx, y: c.y - ry, width: 2.0 * rx, height: 2.0 * ry}
-- --     else
-- --       -- tangent is infinite
-- --       if rotation % (Math.pi / 2.0) == 0.0
-- --       then {x: c.y - ry, y: c.x - rx, width: 2.0 * ry, height: 2.0 * rx}
-- --       else
-- --         let
-- --           tg = Math.tan rotation
-- --           ctg = 1.0 / tg
-- --           sq x = Math.pow x 2.0
-- --           dx =  Math.sqrt $ (sq rx * sq ctg + sq ry) / (1.0 + sq ctg)
-- --           dy =  Math.sqrt $ (sq rx * sq tg + sq ry) / (1.0 + sq tg)
-- --         in
-- --           {x: c.x - dx, y: c.y - dy, width: 2.0 * dx, height: 2.0 * dy }
-- -- 
-- --   Quadrilateral {p1, p2, p3, p4} →
-- --     let
-- --       points = (unsafeCoerce [p1, p2, p3, p4]) ∷ (NonEmptyArray Point)
-- --       maxX = maximum1 (map _.x points)
-- --       maxY = maximum1 (map _.y points)
-- --       minX = minimum1 (map _.x points)
-- --       minY = minimum1 (map _.y points)
-- --     in
-- --       { height: Math.abs (maxY - minY)
-- --       , width: Math.abs (maxX - minX)
-- --       , x: minX
-- --       , y: minY
-- --       }
-- -- 
-- --   Triangle {p1, p2, p3} →
-- --     let
-- --       max v1 v2 v3 = if v1 > v2
-- --         then
-- --           if v3 > v1 then v3 else v1
-- --         else
-- --           if v3 > v2 then v3 else v2
-- --       min v1 v2 v3 = -(max (-v1) (-v2) (-v3))
-- --       maxX = max p1.x p2.x p3.x
-- --       maxY = max p1.y p2.y p3.y
-- --       minX = min p1.x p2.x p3.x
-- --       minY = min p1.y p2.y p3.y
-- --     in
-- --       { height: Math.abs (maxY - minY)
-- --       , width: Math.abs (maxX - minX)
-- --       , x: minX
-- --       , y: minY
-- --       }
-- -- 
-- -- center ∷ Shape → Point
-- -- center = case _ of
-- --   Circle r → r.center
-- --   Ellipse r → r.center
-- --   Quadrilateral r → r.center
-- --   Triangle r → r.center
-- -- 
-- -- radius ∷ Shape → Number
-- -- radius = case _ of
-- --   Circle r → r.radius
-- --   Ellipse { rx, ry } → max rx ry
-- --   Triangle { center: c, p1, p2, p3 } →
-- --     max
-- --       (distance p1 c)
-- --       (max (distance p2 c) (distance p3 c))
-- --   Quadrilateral { center: c, p1, p2, p3, p4 } →
-- --     max (distance p1 c) (distance p2 c)
